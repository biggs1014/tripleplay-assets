<!DOCTYPE html>
<html lang="en">
<head>
 <meta charset="UTF-8" />
 <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
 <title>TRIPLE PLAY 1.0 (Mobile Corrected)</title>
 <style>
:root {
 --tv-blue: #212b47;
 --tv-dark: #131820;
 --tv-gold: #ffe066;
 --tv-white: #f4f5fa;
 --tv-gray: #1a1c26;
 --tv-green: #2ecc40;
 --tv-lime: #a6ff4d;
 --tv-red: #d81c2b;
 --tv-shadow: 0 6px 32px #0008;
}
* { box-sizing: border-box; margin: 0; padding: 0; }
html {
    height: 100%;
}
body {
 font-family: 'Roboto', 'Arial', sans-serif;
 background: linear-gradient(135deg, #0b1623 0%, #24365a 100%);
 display: flex;
 justify-content: center;
 align-items: center;
 min-height: 100vh;
 min-height: 100dvh; /* Dynamic viewport height for mobile */
}
.main-container {
 min-height: 100vh;
 min-height: 100dvh;
 width: 100vw;
 max-width: 100vw;
 background: linear-gradient(120deg, #232a35 20%, #101522 100%);
 display: flex;
 flex-direction: column;
 align-items: center;
 overflow: hidden; /* Prevent body scrollbars */
 position: relative;
 padding: 0;
}
/* Default Portrait Layout */
#game-container {
 width: 100%;
 height: 100%;
 display: flex;
 flex-direction: column;
 align-items: center;
 overflow-y: auto; /* Main scroll for portrait mode */
 overflow-x: hidden;
 padding-top: 18px;
}
canvas {
 border-radius: 18px;
 border: 4px solid var(--tv-blue);
 background: #125b1b radial-gradient(ellipse 130% 90% at 55% 65%, #30803f 50%, #18331e 90%);
 width: 100%;
 max-width: 630px;
 aspect-ratio: 1/1;
 margin-bottom: 18px;
 box-shadow: var(--tv-shadow);
 display: block;
 touch-action: none; /* Prevents scrolling while interacting with canvas on mobile */
}
#controls-panel {
    display: flex;
    flex-direction: column;
    align-items: center;
    width: 100%;
    padding: 0 10px; /* Give some horizontal space */
}
#action-buttons {
 width: 100%;
 max-width: 630px;
 display: flex;
 flex-wrap: wrap;
 justify-content: center;
 gap: 10px;
 margin-bottom: 8px;
}
button {
 border: none;
 outline: none;
 border-radius: 32px;
 padding: 12px 26px;
 background: linear-gradient(180deg, #e9eefa 90%, #b5c3e2 100%);
 color: #16203a;
 font-weight: 900;
 font-family: 'Segoe UI', 'Arial', sans-serif;
 font-size: 1.05em;
 letter-spacing: 0.06em;
 box-shadow: 0 2.5px 18px #0002, 0 1.5px 0px #fff3 inset;
 cursor: pointer;
 transition: background 0.15s, color 0.15s, box-shadow 0.18s, outline 0.12s;
}
button:active {
 background: linear-gradient(180deg, #d1eaff 60%, #a0bde4 100%);
 color: #008f24;
}
button:hover, button:focus-visible {
 background: linear-gradient(180deg, var(--tv-lime) 70%, #fff9e1 100%);
 color: #232a35;
 box-shadow: 0 4px 22px var(--tv-lime), 0 1.5px 0px #fff5 inset;
 outline: 2px solid var(--tv-green);
 outline-offset: 1.5px;
}
#undo-btn {
 background: linear-gradient(180deg, #1d293e 90%, #0b1c3a 100%);
 color: #fff;
 font-weight: bold;
 border: 2px solid var(--tv-gold);
 margin-right: 10px;
}
#undo-btn:hover, #undo-btn:focus-visible {
 background: linear-gradient(180deg, #2a3550 90%, #253048 100%);
 color: var(--tv-lime);
 box-shadow: 0 4px 20px var(--tv-green), 0 1.5px 0px #fff8 inset;
 outline: 2.5px solid var(--tv-green);
}
#undo-btn:disabled {
 opacity: 0.4; color: #dbe5ff; border-color: #555; background: #444; cursor: not-allowed;
}
#scoreboard-container {
 width: 99%;
 max-width: 470px;
 margin: 8px auto 10px auto;
 border-radius: 16px;
 background: linear-gradient(95deg, var(--tv-blue) 60%, var(--tv-gray) 100%);
 box-shadow: 0 2.5px 20px #000b, 0 1.5px 0px #55ff8c77 inset;
 display: flex;
 overflow: hidden;
 border: 3.5px solid #1e2234;
 align-items: stretch;
 font-family: 'Oswald', 'Roboto', 'Arial', sans-serif;
}
.scoreboard-section {
 flex: 1;
 display: flex;
 align-items: center;
 justify-content: center;
 padding: 14px 10px 10px 10px;
 min-width: 0;
}
.scoreboard-section span:first-child { margin-right: 13px; }
.scoreboard-left {
 background: #26334e;
 color: #e7e8fa;
 font-size: 1.25em;
 border-right: 1.5px solid #34415b;
}
.scoreboard-right {
 background: #1a8c20;
 color: #fff;
 font-size: 1.25em;
 border-left: 1.5px solid #34415b;
}
.scoreboard-middle {
 background: #18331e;
 color: var(--tv-lime);
 flex-direction: column;
 min-width: 70px;
 font-family: 'Share Tech Mono', 'Oswald', 'Roboto Mono', 'Consolas', 'Arial', sans-serif;
 text-shadow: 0 2.5px 8px var(--tv-lime), 0 1.5px #232a3577;
 border-radius: 8px;
 font-size: 1.38em;
}
.inning-display { display: flex; align-items: center; justify-content: center; gap: 8px; font-size: 1.3em; }
#inning-arrow {
 color: var(--tv-green);
 font-size: 1.25em;
 margin-right: 4px;
 text-shadow: 0 0 6px var(--tv-green);
}
#inning-number {
 color: var(--tv-lime);
 font-weight: 900;
 font-size: 1.23em;
 font-family: inherit;
}
#outs-display {
 margin-top: 2px;
 font-size: 0.98em;
 color: #e7e8fa;
 text-shadow: 0 1.5px #121820;
}
#mini-base-container {
 position: relative;
 width: 125px;
 height: 80px;
 margin: 10px auto 5px auto;
}
.mini-base {
 position: absolute;
 width: 27px;
 height: 27px;
 background-color: #ecf3fa;
 border: 2px solid #9bb4d5;
 box-shadow: 0 1.5px 7px #121820aa;
 transform: rotate(45deg);
 cursor: pointer;
 transition: background 0.13s, border 0.13s, box-shadow 0.14s;
}
.base-second { bottom: 60px; left: 50%; transform: translate(-50%, 0) rotate(45deg); }
.base-home { bottom: 0; left: 50%; transform: translate(-50%, 0) rotate(45deg); }
.base-first { bottom: 30px; left: calc(50% + 32px); transform: translate(-50%, 0) rotate(45deg); }
.base-third { bottom: 30px; left: calc(50% - 32px); transform: translate(-50%, 0) rotate(45deg); }
.mini-base.occupied {
 background-color: var(--tv-lime) !important;
 border-color: var(--tv-green);
 box-shadow: 0 0 9px var(--tv-green);
}
#animation-log {
 margin-top: 9px;
 max-height: 64px;
 overflow-y: auto;
 width: 93%;
 max-width: 500px;
 background: #232a35;
 color: var(--tv-green);
 border: 2px solid #253048;
 padding: 8px 9px;
 font-size: clamp(0.95em, 1.08vw, 1.13em);
 border-radius: 7px;
 font-family: 'Share Tech Mono', 'Consolas', 'Roboto Mono', monospace;
 box-shadow: 0 2.5px 18px #0003;
}
.status-indicator {
 width: 22px; height: 22px; border-radius: 50%; margin: 6px; display: inline-block; border: 2px solid #fff;
}
.status-connected { background-color: var(--tv-green); }
.status-connecting { background-color: var(--tv-lime); }
.status-disconnected { background-color: var(--tv-red); }

/* --- RESPONSIVE STYLES --- */

/* Smaller phone screens (portrait) */
@media (max-width: 700px) and (orientation: portrait) {
 canvas { max-width: 98vw; }
 #scoreboard-container { max-width: 98vw; }
 .scoreboard-section { font-size: 1em; padding: 8px 2px 7px 2px;}
 button { font-size: 0.95em; padding: 9px 13px; }
 .status-indicator { width: 16px; height: 16px; margin: 2.5px; }
}

/* Landscape orientation for Phones, iPads, and Desktops */
/* THIS IS THE CORRECTED MEDIA QUERY */
@media (orientation: landscape) and (min-width: 700px) {
    .main-container {
        overflow: hidden;
    }
    #game-container {
        flex-direction: row;
        align-items: center; /* Vertically center the columns */
        justify-content: center;
        gap: 20px;
        padding: 20px;
        height: 100%;
        width: 100%;
        overflow: hidden;
    }
    canvas {
        flex-shrink: 0;
        width: auto;
        height: 95%;
        max-width: none;
        max-height: calc(100dvh - 40px); /* Use dynamic height for mobile */
        margin-bottom: 0;
    }
    #controls-panel {
        flex-grow: 1;
        height: calc(100dvh - 40px); /* Fill available height minus padding */
        overflow-y: auto; /* Allow this panel to scroll if content overflows */
        width: 400px; /* A more fixed width */
        max-width: min(45%, 500px); /* Cap width on very large screens */
        padding: 0 15px;
        align-items: center;
        justify-content: flex-start;
    }
    #action-buttons, #scoreboard-container, #mini-base-container, #animation-log, .slider-container {
        width: 100%;
        max-width: 100%; /* Override max-widths set for portrait */
    }
    #animation-log {
        flex-grow: 1; /* Allow log to take up remaining space */
        min-height: 100px; /* Ensure it has a minimum size */
        max-height: none; /* Let it grow */
    }
}
 </style>
 <link href="https://fonts.googleapis.com/css?family=Share+Tech+Mono|Oswald:700&display=swap" rel="stylesheet">
</head>
<body>
 <div class="main-container">
    <div id="game-container">
        <canvas id="baseballCanvas"></canvas>
        <div id="controls-panel">
            <div id="action-buttons">
                <button id="undo-btn" title="Undo Last (Z)" disabled>UNDO</button>
                <button onclick="moveRunners()" title="Spacebar or Enter">MOVE ALL RUNNERS</button>
                <button onclick="resetScenario()" title="Escape">RESET</button>
                <button onclick="speedTestRunners()">TEST: FASTER RUNNERS</button>
                <button id="toggle-preset-btn">SWITCH PRESET (MLB)</button>
            </div>
            <div id="scoreboard-container">
                <div class="scoreboard-section scoreboard-left">
                    <span id="away-team-name">AWAY</span>
                    <span id="away-score">0</span>
                </div>
                <div class="scoreboard-section scoreboard-middle">
                    <div class="inning-display">
                        <span id="inning-arrow">▲</span>
                        <span id="inning-number">1</span>
                    </div>
                    <div id="outs-display">0 OUTS</div>
                </div>
                <div class="scoreboard-section scoreboard-right">
                    <span id="home-team-name">HOME</span>
                    <span id="home-score">0</span>
                </div>
            </div>
            <div id="mini-base-container">
                <div class="mini-base base-third" id="mini-base-third" data-base="third" title="Click to add runner to Third"></div>
                <div class="mini-base base-second" id="mini-base-second" data-base="second" title="Click to add runner to Second"></div>
                <div class="mini-base base-first" id="mini-base-first" data-base="first" title="Click to add runner to First"></div>
                <div class="mini-base base-home" id="mini-base-home" data-base="home" title="Click to add runner to Home"></div>
            </div>
            <div class="slider-container" style="width: 96%; max-width: 500px; margin: 20px auto 8px auto; text-align:center;">
                <label for="runnerSpeedSlider" style="color:#fff; font-weight:bold;">Runner Pace (Elite ←→ Slow):</label>
                <input type="range" id="runnerSpeedSlider" min="3.8" max="4.7" step="0.01" value="4.3" style="width:60%;">
                <span id="runnerSpeedDisplay" style="color:#a6ff4d; margin-left:10px;">4.30s</span>
            </div>
            <div id="animation-log"></div>
            <div style="display: flex; justify-content: center; margin-top: auto; padding: 20px 0;">
                <div style="text-align:center; margin: 0 10px;">
                    <span style="color:white; display:block;">ESP32-1</span>
                    <div id="status-display-1" class="status-indicator status-connecting" title="TRIPLE PLAY HUB Status"></div>
                </div>
                <div style="text-align:center; margin: 0 10px;">
                    <span style="color:white; display:block;">ESP32-2</span>
                    <div id="status-display-2" class="status-indicator status-connecting"></div>
                </div>
                <div style="text-align:center; margin: 0 10px;">
                    <span style="color:white; display:block;">ESP32-3</span>
                    <div id="status-display-3" class="status-indicator status-connecting"></div>
                </div>
                <div style="text-align:center; margin: 0 10px;">
                    <span style="color:white; display:block;">ESP32-4</span>
                    <div id="status-display-4" class="status-indicator status-connecting"></div>
                </div>
            </div>
        </div>
    </div>
 </div>
<script>
// --- GLOBAL CONFIGURATION (Defined and Explained) ---
/** @const {boolean} DEBUG_MODE - Enables detailed console logging for development and troubleshooting. */
const DEBUG_MODE = true;
/** @const {number} DEVICE_PIXEL_RATIO_CAP - Caps rendering resolution on high-DPR screens (like Retina) to 2x. Prevents performance issues on 4K+ monitors by avoiding unnecessarily large canvas buffers. */
const DEVICE_PIXEL_RATIO_CAP = 2;
/** @const {number} DOM_UPDATE_INTERVAL - How often (in milliseconds) to update non-canvas elements like the scoreboard and mini-bases. A lower value is more responsive but uses slightly more CPU. 250ms is a good balance. */
const DOM_UPDATE_INTERVAL = 250;
/** @const {number} BASE_LABEL_FONT_SCALE - Font size for base labels (Home, First, etc.) as a percentage of the canvas width. Allows text to scale with the canvas. */
const BASE_LABEL_FONT_SCALE = 0.02;
/** @const {number} PLAYER_NAME_FONT_SCALE - Font size for player names above runner circles, as a percentage of the canvas width. */
const PLAYER_NAME_FONT_SCALE = 0.035;
/** @const {number} GAME_FPS - The target frames per second for all animations. This is crucial for consistent animation speed across different devices. All speed calculations are based on this value. */
const GAME_FPS = 60;
/** @const {number} BASE_TO_BASE_TIME_RATIO - A runner with a leadoff is faster than one starting from a standstill. This makes base-to-base sprints this percentage (e.g., 85%) of the time it takes to get from home to first. */
const BASE_TO_BASE_TIME_RATIO = 0.85;

// Helper functions
function calcSpeed(seconds) { return 1 / (seconds * GAME_FPS); }
function lerp(a, b, t) { return a + (b - a) * t; }


// --- ESP32 WEBSOCKET CONFIGURATION ---
const ESP32_DEVICES = [
 { name: "TRIPLE PLAY HUB", ip: "192.168.4.1", id: "status-display-1" }
];
// Hide unused status indicators
document.getElementById('status-display-2').parentElement.style.display = 'none';
document.getElementById('status-display-3').parentElement.style.display = 'none';
document.getElementById('status-display-4').parentElement.style.display = 'none';
let esp_websockets = {};

// --- Speed presets use time in seconds (lower time = faster runner) ---
const SPEED_PRESETS = [
 {
  name: "MLB",
  eliteTime: 3.8,
  avgTime: 4.3,
  slowTime: 4.7,
 },
 {
  name: "High School",
  eliteTime: 4.2,
  avgTime: 4.6,
  slowTime: 5.2,
 },
 {
  name: "Little League",
  eliteTime: 4.8,
  avgTime: 5.5,
  slowTime: 6.5,
 }
];
let currentPresetIndex = 0;
let currentSpeedPreset = SPEED_PRESETS[currentPresetIndex];

// ---- The single source of truth for runner speed is a time in seconds ----
let targetHomeToFirstTime = currentSpeedPreset.avgTime;

// --- GLOBAL VARIABLES & DOM REFERENCES ---
let allPlayers = [];
const container = document.getElementById("game-container");
const logElement = document.getElementById("animation-log");
const undoBtn = document.getElementById("undo-btn");
let undoStack = [];
let teamLogos = {};

function saveState() {
 undoStack.push(logic.getState());
 undoBtn.disabled = false;
}
function restoreState(state) {
 if (!state) return;
 logic.setState(state);
 logElement.innerHTML = state.logHTML || "";
 updateScoreboard();
 updateMiniBases();
 redrawNeeded = true;
}
function undo() {
 if (undoStack.length === 0) return;
 animation_gen = null;
 restoreState(undoStack.pop());
 if (undoStack.length === 0) undoBtn.disabled = true;
 addAnimationLog("Undid last action.");
}

// --- ASSET FETCHING ---
fetch('https://raw.githubusercontent.com/biggs1014/tripleplay-assets/main/team_logos.json')
 .then(resp => resp.json())
 .then(data => {
  teamLogos = data;
  addAnimationLog(`Team logos loaded from GitHub: ${Object.keys(teamLogos).length} teams.`);
 })
 .catch(err => addAnimationLog("ERROR: Failed to load team logos from GitHub."));

fetch('https://raw.githubusercontent.com/biggs1014/tripleplay-assets/main/all_players_stats.json')
 .then(resp => resp.json())
 .then(data => {
  allPlayers = data;
  addAnimationLog("MLB player data loaded from GitHub: " + allPlayers.length + " players.");
 })
 .catch(() => addAnimationLog("Failed to load player stats from GitHub. Using defaults."));

const logoImage = new Image();
logoImage.src = "tripleplay1.png";
logoImage.onload = () => redrawNeeded = true;
logoImage.onerror = () => { addAnimationLog("ERROR: Local logo image 'tripleplay1.png' missing."); };

const backgroundImage = new Image();
backgroundImage.src = "field.jpg";
let backgroundImageLoaded = false;
backgroundImage.onload = () => { backgroundImageLoaded = true; addAnimationLog("Local field image loaded."); redrawNeeded = true;};
backgroundImage.onerror = () => { addAnimationLog("ERROR: Local field image 'field.jpg' missing."); backgroundImageLoaded = false; };

function addAnimationLog(message) {
 const newEntry = document.createElement("div");
 newEntry.innerHTML = message;
 logElement.appendChild(newEntry);
 logElement.scrollTop = logElement.scrollHeight;
 if(DEBUG_MODE) console.log(message.replace(/<[^>]*>?/gm, ''));
}

class Runner {
 constructor(pos, base_name, target, player) {
  this.pos = pos;
  this.base = base_name;
  this.target = target;
  this.player = player || { Name: "RANDOM", Speed: 75, "Team Name": "Default" };
  this.current_fraction = 0;
  this.isOut = false;
  this.isMoving = false;
  this.logoImage = null;
  this.logoLoaded = false;
  this.updateSpeed(); // Initial speed calculation
  this.loadLogo();
 }

 // This method calculates speed based on time. It is called
 // every time the slider moves, ensuring speed is always current, even mid-run.
 updateSpeed() {
  let runTime;
  // Determine base run time based on slider
  if (this.base === "home") {
   runTime = targetHomeToFirstTime;
  } else {
   // Base-to-base runs are faster due to leadoffs
   runTime = targetHomeToFirstTime * BASE_TO_BASE_TIME_RATIO;
  }

  // Modify time based on the player's individual speed stat
  // A player with 99 speed will be faster (lower time), 0 speed will be slower (higher time).
  const personalSpeedStat = parseInt(this.player.Speed) || 75;
  const speedStatModifier = lerp(1.1, 0.9, personalSpeedStat / 99);
  runTime *= speedStatModifier;

  // Final calculation converts the time in seconds to a per-frame movement value
  this.speed = calcSpeed(runTime);
 }

 loadLogo() {
  const fullTeamName = this.player["Team Name"];
  if (fullTeamName && teamLogos[fullTeamName]) {
   const svgText = teamLogos[fullTeamName];
   const svgUrl = `data:image/svg+xml,${encodeURIComponent(svgText)}`;
   const img = new Image();
   img.onload = () => { this.logoLoaded = true; redrawNeeded = true; };
   img.onerror = () => { console.error(`Failed to load logo image for ${fullTeamName}`); };
   img.src = svgUrl;
   this.logoImage = img;
  } else if (DEBUG_MODE && fullTeamName && fullTeamName !== "Default") {
   console.log(`Logo not found for team: ${fullTeamName}`);
  }
 }

 clone() { return new Runner([...this.pos], this.base, this.target, { ...this.player }); }

 startRunning() {
  this.isMoving = true;
  this.updateSpeed(); // Ensure speed is current with slider value before running
 }

 updateMovement(startPos, endPos) {
  if (!this.isMoving || this.isOut) return false;
  this.current_fraction += this.speed; // Uses the (potentially just updated) speed
  const frac = Math.min(this.current_fraction, 1);
  this.pos = [lerp(startPos[0], endPos[0], frac), lerp(startPos[1], endPos[1], frac)];
  return frac >= 1;
 }

 arriveAtBase(newBaseName, nextTargetName) {
  this.base = newBaseName;
  this.target = nextTargetName;
  this.current_fraction = 0;
  this.isMoving = false;
 }

 tagOut() {
  this.isOut = true;
  this.isMoving = false;
 }
}

class GameLogic {
 constructor(base_coords) {
  this.base_coords = base_coords;
  this.OFF = 0; this.FLASHING = 1; this.RED = 2;
  this.DEFAULT_FLASH_MS = 400; this.MIN_FLASH_MS = 90;
  this.base_states = {}; this.base_colors = {};
  this.last_toggle_time = {}; this.dynamic_flash_ms = {};
  this.runners = []; this.homeScore = 0; this.awayScore = 0;
  this.outs = 0; this.inning = 1; this.topOfInning = true;
  for (const name in base_coords) {
   this.base_states[name] = this.OFF;
   this.base_colors[name] = "#f4f5fa";
   this.last_toggle_time[name] = performance.now();
   this.dynamic_flash_ms[name] = this.DEFAULT_FLASH_MS;
  }
 }

 sendAllBaseStates() {
  const statePayload = {
   home: this.base_states.home,
   first: this.base_states.first,
   second: this.base_states.second,
   third: this.base_states.third
  };
  const jsonString = JSON.stringify(statePayload);
  for (const ip in esp_websockets) {
   const ws = esp_websockets[ip];
   if (ws && ws.readyState === WebSocket.OPEN) {
    ws.send(jsonString);
    if (DEBUG_MODE) console.log(`Sent to ${ip}:`, jsonString);
   }
  }
 }

 set_base_default(base_name) {
  this.base_states[base_name] = this.OFF;
  this.base_colors[base_name] = "#f4f5fa";
  this.dynamic_flash_ms[base_name] = this.DEFAULT_FLASH_MS;
  redrawNeeded = true;
  this.sendAllBaseStates();
 }
 set_base_flashing(base_name) {
  this.base_states[base_name] = this.FLASHING;
  if (!this.last_toggle_time[base_name]) this.last_toggle_time[base_name] = performance.now();
  if (this.base_colors[base_name] !== "#2ecc40" && this.base_colors[base_name] !== "#f4f5fa") {
   this.base_colors[base_name] = "#2ecc40";
  }
  redrawNeeded = true;
  this.sendAllBaseStates();
 }
 set_base_red(base_name) {
  this.base_states[base_name] = this.RED;
  this.base_colors[base_name] = "#d81c2b";
  this.dynamic_flash_ms[base_name] = this.DEFAULT_FLASH_MS;
  redrawNeeded = true;
  this.sendAllBaseStates();
 }

 clearBases() {
  this.runners = [];
  for (const b in this.base_states) this.set_base_default(b);
  addAnimationLog("All bases cleared.");
  redrawNeeded = true;
 }
 recordOut() {
  this.outs++;
  addAnimationLog(`Out recorded! Total outs: ${this.outs}`);
  if (this.outs >= 3) {
   this.outs = 0;
   addAnimationLog("Three outs! Switching half-inning...");
   this.nextInning();
  }
  redrawNeeded = true;
 }
 nextInning() {
  if (this.topOfInning) {
   this.topOfInning = false;
   addAnimationLog(`Now entering bottom of inning ${this.inning}`);
  } else {
   this.inning++;
   this.topOfInning = true;
   addAnimationLog(`Now entering top of inning ${this.inning}`);
  }
  this.clearBases();
  redrawNeeded = true;
 }
 scoreRun() {
  if (this.topOfInning) {
   this.awayScore++;
   addAnimationLog(`Away team scores! New score => Away: ${this.awayScore}`);
  } else {
   this.homeScore++;
   addAnimationLog(`Home team scores! New score => Home: ${this.homeScore}`);
  }
  redrawNeeded = true;
 }
 reset_all() {
  this.homeScore = 0; this.awayScore = 0; this.outs = 0;
  this.inning = 1; this.topOfInning = true;
  this.clearBases();
  addAnimationLog("Game state has been fully reset.");
  redrawNeeded = true;
 }
 add_runner(base_name) {
  saveState();
  if (this.runners.some((r) => r.base === base_name && !r.isOut)) {
   addAnimationLog(`Cannot add runner: ${base_name.toUpperCase()} is already occupied.`);
   return;
  }
  if (this.runners.some(r => !r.isOut && r.isMoving && r.target === base_name)) {
   addAnimationLog(`Cannot add runner: A runner is already advancing to ${base_name.toUpperCase()}.`);
   return;
  }
  const pos = this.get_runner_position(base_name);
  const target = this.get_next_base(base_name);
  let player = { Name: "RANDOM", Speed: 75, "Team Name": "Default" };
  if (allPlayers.length > 0) {
   player = allPlayers[Math.floor(Math.random() * allPlayers.length)];
  }
  const runner = new Runner(pos, base_name, target, player);
  this.runners.push(runner);
  this.set_base_red(base_name);
  addAnimationLog(`Runner added at ${base_name.toUpperCase()}: <b>${runner.player.Name}</b> (${runner.player["Team Name"]}, Speed: ${runner.player.Speed})`);
  redrawNeeded = true;
 }
 get_runner_position(base_name) { return [...this.base_coords[base_name]]; }
 get_next_base(current_base) {
  switch (current_base) {
   case "home": return "first";
   case "first": return "second";
   case "second": return "third";
   case "third": return "home";
   default: return "home";
  }
 }
 remove_runner_from_base(runner) {
  const idx = this.runners.indexOf(runner);
  if (idx > -1) {
   this.runners.splice(idx, 1);
   redrawNeeded = true;
  }
 }
 update_flashing() {
  const now = performance.now();
  for (const base_name in this.base_states) {
   if (this.base_states[base_name] === this.FLASHING) {
    const elapsed = now - this.last_toggle_time[base_name];
    if (elapsed >= this.dynamic_flash_ms[base_name]) {
     this.base_colors[base_name] = this.base_colors[base_name] === "#2ecc40" ? "#f4f5fa" : "#2ecc40";
     this.last_toggle_time[base_name] = now;
     redrawNeeded = true;
    }
   }
  }
 }

 _resolveRunnerArrival(runner) {
  const targetBaseName = runner.target;
  if (targetBaseName === 'home') {
   addAnimationLog(`<b>${runner.player.Name}</b> reached HOME => scoring a run!`);
   this.scoreRun();
   runner.base = 'scored';
   runner.isMoving = false;
   return;
  }
  const occupant = this.runners.find(r => r.base === targetBaseName && !r.isOut && r !== runner);
  if (occupant) {
   runner.tagOut();
   addAnimationLog(`<b>${runner.player.Name}</b> is OUT: ${targetBaseName.toUpperCase()} is already occupied by <b>${occupant.player.Name}</b>.`);
   this.recordOut();
   return;
  }
  const nextTarget = this.get_next_base(targetBaseName);
  runner.arriveAtBase(targetBaseName, nextTarget);
  addAnimationLog(`<b>${runner.player.Name}</b> arrived safely at ${targetBaseName.toUpperCase()}`);
 }

 _updateAllBaseVisuals() {
  for (const base_name in this.base_states) {
   const isOccupied = this.runners.some(r => r.base === base_name && !r.isOut);
   if (isOccupied) {
    this.set_base_red(base_name);
   } else {
    this.set_base_default(base_name);
   }
  }
 }

 move_all_runners() {
  saveState();
  const runnersToMove = this.runners.filter((r) => !r.isOut && !r.isMoving);
  if (!runnersToMove.length) {
   addAnimationLog("No runners on base to move.");
   return null;
  }

  addAnimationLog("Moving all runners...");
  runnersToMove.forEach(runner => runner.startRunning());

  const transitions = runnersToMove.map((runner) => ({
   runner,
   start: this.get_runner_position(runner.base),
   end: this.base_coords[runner.target]
  }));

  for (const base_name in this.base_states) {
   const isBeingAdvancedTo = transitions.some(t => t.runner.target === base_name);
   const isOccupiedAndStaying = this.runners.some(r => r.base === base_name && !r.isMoving && !r.isOut);
   if (isBeingAdvancedTo) {
    this.set_base_flashing(base_name);
   } else if (isOccupiedAndStaying) {
    this.set_base_red(base_name);
   } else {
    this.set_base_default(base_name);
   }
  }

  return (function* (logic, transitions) {
   let allFinished = false;
   while (!allFinished) {
    allFinished = true;
    transitions = transitions.filter(t => !t.runner.isOut);

    for (const t of transitions) {
     const finishedThisFrame = t.runner.updateMovement(t.start, t.end);
     if (!finishedThisFrame) {
      allFinished = false;
     }
    }

    for (const base_name in logic.base_states) {
     if (logic.base_states[base_name] === logic.FLASHING) {
      const runnersApproaching = transitions.filter(t => t.runner.target === base_name && !t.runner.isOut);
      if (runnersApproaching.length > 0) {
       const closestRunner = runnersApproaching.reduce((prev, curr) =>
        (prev.runner.current_fraction > curr.runner.current_fraction) ? prev : curr
       );
       const frac = Math.min(closestRunner.runner.current_fraction, 1);
       const minFlash = logic.MIN_FLASH_MS, maxFlash = logic.DEFAULT_FLASH_MS;
       logic.dynamic_flash_ms[base_name] = maxFlash - (maxFlash - minFlash) * frac;
      } else {
       logic.set_base_default(base_name);
      }
     }
    }
    redrawNeeded = true;
    yield;
   }

   // --- BUG FIX: Process runner arrivals in correct order to avoid race conditions ---
   const finishedRunners = transitions.map(t => t.runner).filter(r => !r.isOut);
   const baseOrder = { 'third': 3, 'second': 2, 'first': 1, 'home': 0 };

   // Sort runners based on their starting base, descending.
   // A runner from 'second' (2) is processed before a runner from 'first' (1).
   finishedRunners.sort((a, b) => (baseOrder[b.base] || -1) - (baseOrder[a.base] || -1));

   for (const runner of finishedRunners) {
    logic._resolveRunnerArrival(runner);
   }
   // --- END BUG FIX ---

   logic.runners = logic.runners.filter(r => r.base !== 'scored' && !r.isOut);
   logic._updateAllBaseVisuals();
   addAnimationLog("All runner movements complete.");
  }).bind(this)(this, transitions);
 }

 getState() {
  return {
   base_coords: this.base_coords,
   base_states: { ...this.base_states },
   base_colors: { ...this.base_colors },
   last_toggle_time: { ...this.last_toggle_time },
   dynamic_flash_ms: { ...this.dynamic_flash_ms },
   runners: this.runners.map(r => ({
    pos: [...r.pos],
    base: r.base,
    target: r.target,
    player: { ...r.player },
    speed: r.speed,
    current_fraction: r.current_fraction,
    isOut: r.isOut,
    isMoving: r.isMoving
   })),
   homeScore: this.homeScore,
   awayScore: this.awayScore,
   outs: this.outs,
   inning: this.inning,
   topOfInning: this.topOfInning,
   logHTML: logElement.innerHTML
  };
 }
 setState(state) {
  Object.assign(this, state);
  this.runners = state.runners.map(rData =>
   new Runner(rData.pos, rData.base, rData.target, rData.player)
  );
 }
}

// --- CANVAS & RENDERING LOGIC ---
const canvas = document.getElementById("baseballCanvas");
const ctx = canvas.getContext("2d");
let canvasWidth = 600, canvasHeight = 600;
const base_coords = {
 home: [canvasWidth / 2, canvasHeight * 0.8],
 first: [canvasWidth * 0.7, canvasHeight * 0.6],
 second: [canvasWidth / 2, canvasHeight * 0.4],
 third: [canvasWidth * 0.3, canvasHeight * 0.6],
};
const logic = new GameLogic(base_coords);
let animation_gen = null, redrawNeeded = true, resizeNeeded = true;

function resizeCanvas() {
 const dpr = Math.min(window.devicePixelRatio || 1, DEVICE_PIXEL_RATIO_CAP);
 const rect = canvas.getBoundingClientRect();
 
 if (rect.width === 0 || rect.height === 0) return;

 canvas.width = rect.width * dpr;
 canvas.height = rect.height * dpr;
 
 canvasWidth = canvas.width;
 canvasHeight = canvas.height;
 const norm = {
  home: [0.5, 0.8], first: [0.7, 0.6], second: [0.5, 0.4], third: [0.3, 0.6],
 };
 logic.base_coords = {
  home: [canvasWidth * norm.home[0], canvasHeight * norm.home[1]],
  first: [canvasWidth * norm.first[0], canvasHeight * norm.first[1]],
  second: [canvasWidth * norm.second[0], canvasHeight * norm.second[1]],
  third: [canvasWidth * norm.third[0], canvasHeight * norm.third[1]],
 };
 logic.runners.forEach(r => { if (!r.isMoving) r.pos = logic.get_runner_position(r.base); });
 redrawNeeded = true;
}

function draw_field() {
 ctx.clearRect(0, 0, canvas.width, canvas.height);
 if (backgroundImageLoaded && backgroundImage) {
  ctx.drawImage(backgroundImage, 0, 0, canvas.width, canvas.height);
 } else {
  ctx.fillStyle = "#30803f";
  ctx.fillRect(0, 0, canvas.width, canvas.height);
 }
 const bc = logic.base_coords;
 const mx = (bc.home[0] + bc.second[0]) / 2;
 const my = (bc.home[1] + bc.second[1]) / 2;
 ctx.save();
 ctx.globalAlpha = 0.9;
 ctx.shadowColor = "#a6ff4d";
 ctx.shadowBlur = 17;
 ctx.fillStyle = "#f6d89b";
 ctx.strokeStyle = "#358c21";
 ctx.beginPath();
 ctx.arc(mx, my, canvasWidth * 0.021, 0, 2 * Math.PI);
 ctx.fill();
 ctx.stroke();
 ctx.restore();
 const BASE_HALF = canvasWidth * 0.032;
 for (const base in bc) {
  const [x, y] = bc[base];
  ctx.save();
  ctx.shadowColor = "#a6ff4d";
  ctx.shadowBlur = 13;
  ctx.globalAlpha = 0.91;
  ctx.fillStyle = logic.base_colors[base];
  ctx.strokeStyle = "#358c21";
  ctx.beginPath();
  ctx.moveTo(x, y - BASE_HALF);
  ctx.lineTo(x + BASE_HALF, y);
  ctx.lineTo(x, y + BASE_HALF);
  ctx.lineTo(x - BASE_HALF, y);
  ctx.closePath();
  ctx.fill();
  ctx.shadowBlur = 0;
  ctx.globalAlpha = 1;
  ctx.lineWidth = 3;
  ctx.stroke();
  ctx.font = `900 ${Math.floor(canvasWidth * BASE_LABEL_FONT_SCALE)}px 'Oswald','Arial Black',Arial,sans-serif`;
  ctx.textAlign = "center";
  ctx.fillStyle = "#18331e";
  ctx.shadowColor = "#a6ff4d";
  ctx.shadowBlur = 6;
  ctx.fillText(base.toUpperCase(), x, y - BASE_HALF - 10);
  ctx.restore();
 }
 if (logoImage.complete && logoImage.width) {
  const logoHeight = canvasHeight * 0.17;
  const logoWidth = logoHeight * (logoImage.width / logoImage.height);
  ctx.drawImage(logoImage, (canvasWidth - logoWidth) / 2, canvasHeight * 0.05, logoWidth, logoHeight);
 }
}

function draw_runners() {
 for (const r of logic.runners) {
  if (!r.isOut) {
   const [x, y] = r.pos;
   const runnerRadius = canvasWidth * 0.025;

   ctx.save();
   ctx.shadowColor = "#a6ff4d";
   ctx.shadowBlur = 8;
   ctx.globalAlpha = 0.92;
   ctx.fillStyle = "#c90019";
   ctx.beginPath();
   ctx.arc(x, y, runnerRadius, 0, 2 * Math.PI);
   ctx.fill();
   ctx.shadowBlur = 0;
   ctx.globalAlpha = 1;
   ctx.lineWidth = 2;
   ctx.strokeStyle = "#a6ff4d";
   ctx.stroke();
   ctx.restore();

   const whiteBgRadius = runnerRadius * 0.9;
   ctx.save();
   ctx.fillStyle = 'white';
   ctx.beginPath();
   ctx.arc(x, y, whiteBgRadius, 0, 2 * Math.PI);
   ctx.fill();
   ctx.restore();

   if (r.logoLoaded && r.logoImage) {
    const logoSize = whiteBgRadius * 1.8;
    const logoX = x - logoSize / 2;
    const logoY = y - logoSize / 2;
    ctx.drawImage(r.logoImage, logoX, logoY, logoSize, logoSize);
   }
   ctx.save();
   const name = r.player?.Name.toUpperCase() || "RANDOM";
   ctx.font = `bold ${Math.floor(canvasWidth * PLAYER_NAME_FONT_SCALE)}px 'Share Tech Mono','Oswald','Arial',sans-serif`;
   ctx.textAlign = "center";
   ctx.textBaseline = "bottom";
   const gapAboveCircle = canvasWidth * 0.015;
   const nameBaselineY = y - runnerRadius - gapAboveCircle;
   ctx.lineWidth = 4;
   ctx.strokeStyle = "#18331e";
   ctx.strokeText(name, x, nameBaselineY);
   ctx.fillStyle = "#a6ff4d";
   ctx.shadowColor = "#232a35";
   ctx.shadowBlur = 10;
   ctx.fillText(name, x, nameBaselineY);
   ctx.restore();
  }
 }
}

function updateScoreboard() {
 document.getElementById("away-score").textContent = logic.awayScore;
 document.getElementById("home-score").textContent = logic.homeScore;
 document.getElementById("inning-arrow").textContent = logic.topOfInning ? "▲" : "▼";
 document.getElementById("inning-number").textContent = logic.inning;
 document.getElementById("outs-display").textContent = `${logic.outs} OUTS`;
}
function updateMiniBases() {
 ["home", "first", "second", "third"].forEach(base => {
  const el = document.getElementById(`mini-base-${base}`);
  if (el) {
   if (logic.runners.some(r => r.base === base && !r.isOut)) {
    el.classList.add("occupied");
   } else {
    el.classList.remove("occupied");
   }
  }
 });
}

// --- MAIN GAME LOOP & EVENT HANDLERS ---
function update_gui() {
 if (resizeNeeded) { resizeCanvas(); resizeNeeded = false; }
 logic.update_flashing();
 if (animation_gen) {
  const next = animation_gen.next();
  if (next.done) animation_gen = null;
 }
 if (redrawNeeded) {
  draw_field();
  draw_runners();
  redrawNeeded = false;
 }
 requestAnimationFrame(update_gui);
}
update_gui(); // Start the animation loop

setInterval(() => {
 updateScoreboard();
 updateMiniBases();
}, DOM_UPDATE_INTERVAL);

// --- USER ACTIONS ---
function moveRunners() {
 if (animation_gen) return;
 const steps = logic.move_all_runners();
 if (steps) animation_gen = steps;
}
function speedTestRunners() {
 if (animation_gen) return;
 const tempRunners = logic.runners.filter(r => !r.isOut && !r.isMoving);
 if (tempRunners.length > 0) {
    saveState();
    addAnimationLog("Speed test engaged: runners are 3x faster!");
    tempRunners.forEach(r => r.speed *= 3);
    const steps = logic.move_all_runners();
    if (steps) animation_gen = steps;
 } else {
    addAnimationLog("No runners to speed test.");
 }
}
function resetScenario() {
 animation_gen = null;
 logic.reset_all();
 logElement.innerHTML = '';
 undoStack = [];
 undoBtn.disabled = true;
 addAnimationLog("Scenario has been reset.");
}
function tagRunnerOut(runner) {
 if (runner.isOut) return;
 saveState();
 runner.tagOut();
 addAnimationLog(`<b>${runner.player.Name}</b> (moving from ${runner.base} to ${runner.target}) is tagged out!`);
 logic.recordOut();
 const base = runner.base;
 const stillOccupied = logic.runners.some(r => r.base === base && !r.isOut);
 if (!stillOccupied) {
  logic.set_base_default(base);
 }
 redrawNeeded = true;
}

document.querySelectorAll(".mini-base").forEach(baseElement => {
 baseElement.addEventListener("click", () => {
  const base = baseElement.getAttribute("data-base");
  logic.add_runner(base);
 });
});
undoBtn.addEventListener('click', undo);

function handleCanvasInteraction(event) {
 event.preventDefault();
 let pointerX, pointerY;
 if (event.type.startsWith("touch")) {
  if (event.touches.length > 0) {
   pointerX = event.touches[0].clientX;
   pointerY = event.touches[0].clientY;
  } else { return; }
 } else {
  pointerX = event.clientX;
  pointerY = event.clientY;
 }
 const rect = canvas.getBoundingClientRect();
 const scaleX = canvas.width / rect.width;
 const scaleY = canvas.height / rect.height;
 const clickX = (pointerX - rect.left) * scaleX;
 const clickY = (pointerY - rect.top) * scaleY;
 const clickRadius = canvasWidth * 0.03;

 for (const runner of logic.runners) {
  if (!runner.isOut) {
   const [rx, ry] = runner.pos;
   if (Math.hypot(clickX - rx, clickY - ry) < clickRadius) {
    tagRunnerOut(runner);
    return;
   }
  }
 }

 if (animation_gen) {
  const baseClickRadius = canvasWidth * 0.04;
  for (const baseName in logic.base_coords) {
   const [baseX, baseY] = logic.base_coords[baseName];
   if (Math.hypot(clickX - baseX, clickY - baseY) < baseClickRadius) {
    const runnerToTag = logic.runners.find(
     r => r.isMoving && !r.isOut && r.target === baseName
    );
    if (runnerToTag) {
     addAnimationLog(`Force out at ${baseName.toUpperCase()}!`);
     tagRunnerOut(runnerToTag);
     return;
    }
   }
  }
 }

 const mound_x = (logic.base_coords.home[0] + logic.base_coords.second[0]) / 2;
 const mound_y = (logic.base_coords.home[1] + logic.base_coords.second[1]) / 2;
 if (!animation_gen && Math.hypot(clickX - mound_x, clickY - mound_y) < clickRadius * 2) {
  moveRunners();
  return;
 }
}

canvas.addEventListener("pointerdown", handleCanvasInteraction);
canvas.addEventListener("touchstart", handleCanvasInteraction, { passive: false });
window.addEventListener("resize", () => { resizeNeeded = true; });

// Use ResizeObserver for more reliable detection of size changes.
const resizeObserver = new ResizeObserver(() => {
    resizeNeeded = true;
});
resizeObserver.observe(canvas);

document.addEventListener('keydown', e => {
 if (e.target.tagName === 'INPUT' || e.target.tagName === 'BUTTON') return;
 if (e.key === " " || e.key === "Spacebar") { e.preventDefault(); moveRunners(); }
 else if (e.key === "Enter") { e.preventDefault(); moveRunners(); }
 else if (e.key === "Escape") { e.preventDefault(); resetScenario(); }
 else if (e.key.toLowerCase() === "z" && (e.ctrlKey || e.metaKey)) { e.preventDefault(); undo(); }
});

// --- UI CONTROL LOGIC ---
const runnerSpeedSlider = document.getElementById("runnerSpeedSlider");
const runnerSpeedDisplay = document.getElementById("runnerSpeedDisplay");
runnerSpeedSlider.addEventListener("input", function(event) {
 targetHomeToFirstTime = parseFloat(event.target.value);
 runnerSpeedDisplay.textContent = targetHomeToFirstTime.toFixed(2) + "s";
 logic.runners.forEach(runner => runner.updateSpeed());
});

const togglePresetBtn = document.getElementById("toggle-preset-btn");
togglePresetBtn.addEventListener("click", () => {
 currentPresetIndex = (currentPresetIndex + 1) % SPEED_PRESETS.length;
 currentSpeedPreset = SPEED_PRESETS[currentPresetIndex];
 addAnimationLog(`Switched to ${currentSpeedPreset.name} speed preset.`);

 runnerSpeedSlider.min = currentSpeedPreset.eliteTime;
 runnerSpeedSlider.max = currentSpeedPreset.slowTime;
 runnerSpeedSlider.value = currentSpeedPreset.avgTime;
 togglePresetBtn.textContent = `SWITCH PRESET (${currentSpeedPreset.name})`;

 // Programmatically trigger the slider's input event to update everything
 runnerSpeedSlider.dispatchEvent(new Event('input'));
});

// --- ESP32 WEBSOCKET INITIALIZATION ---
function connectToDevice(device) {
 const statusIndicator = document.getElementById(device.id);
 addAnimationLog(`Attempting to connect to ${device.name} at ws://${device.ip}/ws ...`);
 statusIndicator.className = 'status-indicator status-connecting';
 const ws = new WebSocket(`ws://${device.ip}/ws`);
 esp_websockets[device.ip] = ws;
 ws.onopen = function(event) {
  addAnimationLog(`✅ Successfully connected to ${device.name}.`);
  statusIndicator.className = 'status-indicator status-connected';
  logic.sendAllBaseStates();
 };
 ws.onclose = function(event) {
  addAnimationLog(`❌ Disconnected from ${device.name}. Reconnecting in 5s...`);
  statusIndicator.className = 'status-indicator status-disconnected';
  setTimeout(() => connectToDevice(device), 5000);
 };
 ws.onerror = function(error) {
  addAnimationLog(`WebSocket error with ${device.name}. Check console.`);
  statusIndicator.className = 'status-indicator status-disconnected';
  console.error(`WebSocket Error for ${device.name}: `, error);
 };
 ws.onmessage = function(event) {
  if (DEBUG_MODE) console.log(`Message from ${device.name}:`, event.data);
 };
}
function initializeAllConnections() {
 ESP32_DEVICES.forEach(device => connectToDevice(device));
}
initializeAllConnections();
</script>
</body>
</html>
